{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.4", "generated_at": "2025-11-05T01:01:15.639901Z", "invocation_id": "7e83ba00-13a6-4bbe-8444-6c0af9989498", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-05T01:01:08.762642Z", "completed_at": "2025-11-05T01:01:08.782591Z"}, {"name": "execute", "started_at": "2025-11-05T01:01:08.783279Z", "completed_at": "2025-11-05T01:01:11.119310Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 2.358217716217041, "adapter_response": {"_message": "SUCCESS 1", "code": "SUCCESS", "rows_affected": 1, "query_id": "01c02d5d-0206-e0d0-0032-318704d78886"}, "message": "SUCCESS 1", "failures": null, "unique_id": "model.incident_management.v_qualify_new_documents", "compiled": true, "compiled_code": "\n\nselect\n   *,\n    case \n        when contains(relative_path, 'qa') then 'question'\n        when contains(relative_path, 'full') then 'full'\n        else 'full'\n    end as analysis_type,\n    split_part(relative_path, '.', 2) as extension\nfrom incident_management.bronze_zone.documents_stream\nWHERE relative_path is not null\nand array_contains(extension::VARIANT, ['pdf', 'docx', 'doc', 'txt', 'text', 'html', 'md', 'pptx', 'ppt', 'png', 'eml', 'jpg', 'jpeg', 'gif', 'bmp', 'tiff', 'tif', 'webp', 'htm'] )\nand size > 0", "relation_name": "incident_management.bronze_zone.v_qualify_new_documents", "batch_results": null}, {"status": "error", "timing": [{"name": "compile", "started_at": "2025-11-05T01:01:11.128214Z", "completed_at": "2025-11-05T01:01:11.168666Z"}, {"name": "execute", "started_at": "2025-11-05T01:01:11.169366Z", "completed_at": "2025-11-05T01:01:15.624131Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 4.503249645233154, "adapter_response": {}, "message": "Database Error in model document_question_extracts (models/bronze_zone/document_question_extracts.py)\n  100357 (P0000): Python Interpreter Error:\n  Traceback (most recent call last):\n    File \"_udf_code.py\", line 118, in main\n      df = model(dbt, session)\n    File \"_udf_code.py\", line 41, in model\n      get_response_format(asset_path, F.col('relative_path'))\n    File \"_udf_code.py\", line 13, in get_response_format\n      with open(f'global_inm_policy_schema.json', 'r') as f:\n  FileNotFoundError: [Errno 2] No such file or directory: 'global_inm_policy_schema.json'\n   in function DOCUMENT_QUESTION_EXTRACTS__DBT_SP with handler main\n  compiled code at /tmp/dbt/target/run/incident_management/models/bronze_zone/document_question_extracts.py", "failures": null, "unique_id": "model.incident_management.document_question_extracts", "compiled": true, "compiled_code": "import snowflake.snowpark.functions as F\nfrom snowflake.snowpark import Session\nimport json\n\ndef get_response_format(asset_path: str, relative_path: str):\n    with open(f'global_inm_policy_schema.json', 'r') as f:\n        response_format = json.load(f)\n    return response_format\n\ndef model(dbt, session: Session):\n    dbt.config(\n        materialized='table',\n        description='Table to store question extracts from documents'\n    )\n    \n    asset_path = dbt.config.get(\"asset-paths\")\n    docs_stage = dbt.config.get(\"docs_stage_path\")\n    \n    # Get the upstream model\n    v_qualify_new_documents = dbt.ref('v_qualify_new_documents')\n    \n    # Filter for question analysis type\n    document_all_pages = v_qualify_new_documents.filter(\n        F.col('analysis_type') == 'question'\n    )\n    \n    # Add AI_EXTRACT column\n    # Note: AI_EXTRACT with TO_FILE and response_format needs to be done via SQL expression\n    document_all_pages = document_all_pages.with_column(\n        'question_extracts_json',\n        F.call_builtin(\n            'AI_EXTRACT',\n            F.call_builtin('TO_FILE', F.lit(f'{docs_stage}/qa'), F.col('relative_path')),\n            get_response_format(asset_path, F.col('relative_path'))\n        )\n    )\n    \n    return document_all_pages\n\n\n# This part is user provided model code\n# you will need to copy the next section to run the code\n# COMMAND ----------\n# this part is dbt logic for get ref work, do not modify\n\ndef ref(*args, **kwargs):\n    refs = {\"v_qualify_new_documents\": \"incident_management.bronze_zone.v_qualify_new_documents\"}\n    key = '.'.join(args)\n    version = kwargs.get(\"v\") or kwargs.get(\"version\")\n    if version:\n        key += f\".v{version}\"\n    dbt_load_df_function = kwargs.get(\"dbt_load_df_function\")\n    return dbt_load_df_function(refs[key])\n\n\ndef source(*args, dbt_load_df_function):\n    sources = {}\n    key = '.'.join(args)\n    return dbt_load_df_function(sources[key])\n\n\nconfig_dict = {'asset-paths': None, 'docs_stage_path': None}\n\n\nclass config:\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @staticmethod\n    def get(key, default=None):\n        return config_dict.get(key, default)\n\nclass this:\n    \"\"\"dbt.this() or dbt.this.identifier\"\"\"\n    database = \"incident_management\"\n    schema = \"bronze_zone\"\n    identifier = \"document_question_extracts\"\n    \n    def __repr__(self):\n        return 'incident_management.bronze_zone.document_question_extracts'\n\n\nclass dbtObj:\n    def __init__(self, load_df_function) -> None:\n        self.source = lambda *args: source(*args, dbt_load_df_function=load_df_function)\n        self.ref = lambda *args, **kwargs: ref(*args, **kwargs, dbt_load_df_function=load_df_function)\n        self.config = config\n        self.this = this()\n        self.is_incremental = False\n\n# COMMAND ----------\n\n\n", "relation_name": "incident_management.bronze_zone.document_question_extracts", "batch_results": null}], "elapsed_time": 12.083512783050537, "args": {"profiles_dir": "/tmp/dbt/", "project_dir": "/tmp/dbt", "require_nested_cumulative_type_params": false, "print": true, "printer_width": 80, "partial_parse": true, "require_resource_names_without_spaces": false, "state_modified_compare_vars": false, "require_batched_execution_for_custom_microbatch_strategy": false, "target_path": "/tmp/dbt/target/", "static_parser": true, "log_level_file": "debug", "cache_selected_only": false, "target": "dev", "source_freshness_run_project_hooks": false, "exclude": [], "macro_debugging": false, "use_colors_file": true, "log_format_file": "debug", "skip_nodes_if_on_run_start_fails": false, "state_modified_compare_more_unrendered_values": false, "send_anonymous_usage_stats": false, "which": "run", "empty": false, "favor_state": false, "indirect_selection": "eager", "require_explicit_package_overrides_for_builtin_materializations": true, "quiet": false, "introspect": true, "invocation_command": "dbt ", "populate_cache": true, "require_yaml_configuration_for_mf_time_spines": false, "log_file_max_bytes": 10485760, "use_colors": true, "log_format": "default", "select": ["+bronze_zone.document_question_extracts"], "version_check": true, "vars": {}, "partial_parse_file_diff": true, "show_resource_report": false, "defer": false, "write_json": true, "warn_error_options": {"include": [], "exclude": []}, "log_path": "/tmp/dbt/logs", "log_level": "info", "strict_mode": false}}