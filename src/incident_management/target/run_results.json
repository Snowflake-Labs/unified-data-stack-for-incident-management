{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.4", "generated_at": "2025-11-07T21:18:15.879997Z", "invocation_id": "264ee1d1-1bf6-40a6-9699-f18700c15104", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-07T21:16:51.524510Z", "completed_at": "2025-11-07T21:16:51.544481Z"}, {"name": "execute", "started_at": "2025-11-07T21:16:51.545164Z", "completed_at": "2025-11-07T21:16:52.819158Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 1.2961907386779785, "adapter_response": {"_message": "SUCCESS 1", "code": "SUCCESS", "rows_affected": 1, "query_id": "01c03d5c-0206-e95a-0032-318704fe0532"}, "message": "SUCCESS 1", "failures": null, "unique_id": "model.incident_management.v_qualify_new_documents", "compiled": true, "compiled_code": "\n\nselect\n   *,\n    case \n        when contains(relative_path, 'qa') then 'question'\n        when contains(relative_path, 'full') then 'full'\n        else 'full'\n    end as analysis_type,\n    split_part(relative_path, '.', 2) as extension\nfrom incident_management.bronze_zone.documents_stream\nWHERE relative_path is not null\nand array_contains(extension::VARIANT, ['pdf', 'docx', 'doc', 'txt', 'text', 'html', 'md', 'pptx', 'ppt', 'png', 'eml', 'jpg', 'jpeg', 'gif', 'bmp', 'tiff', 'tif', 'webp', 'htm'] )\nand size > 0", "relation_name": "incident_management.bronze_zone.v_qualify_new_documents", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-11-07T21:16:52.828570Z", "completed_at": "2025-11-07T21:16:52.869983Z"}, {"name": "execute", "started_at": "2025-11-07T21:16:52.870880Z", "completed_at": "2025-11-07T21:18:15.871987Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 83.04515171051025, "adapter_response": {"_message": "SUCCESS 1", "code": "SUCCESS", "rows_affected": 1, "query_id": "01c03d5c-0206-e95a-0032-318704fe0552"}, "message": "SUCCESS 1", "failures": null, "unique_id": "model.incident_management.document_question_extracts", "compiled": true, "compiled_code": "import snowflake.snowpark.functions as F\nfrom snowflake.snowpark import Session\nimport json\n\n    \ndef model(dbt, session: Session):\n    dbt.config(\n        materialized='table',\n        description='Table to store question extracts from documents'\n    )\n    \n    docs_stage = dbt.config.get(\"docs_stage_path\")\n    global_inm_policy_schema = dbt.config.get(\"meta\")['global_inm_policy_schema']\n\n    # Get the upstream model\n    v_qualify_new_documents = dbt.ref('v_qualify_new_documents')\n    \n    # Filter for question analysis type\n    document_all_pages = v_qualify_new_documents.filter(\n        F.col('analysis_type') == 'question'\n    )\n    \n    # Add AI_EXTRACT column\n    # Note: AI_EXTRACT with TO_FILE and response_format needs to be done via SQL expression\n    document_all_pages = document_all_pages.with_column(\n        'question_extracts_json',\n        F.call_builtin(\n            'AI_EXTRACT',\n            F.call_builtin('TO_FILE', F.lit('@INCIDENT_MANAGEMENT.bronze_zone.DOCUMENTS'), F.col('relative_path')),\n            global_inm_policy_schema\n        )\n    )    \n    return document_all_pages\n\n\n# This part is user provided model code\n# you will need to copy the next section to run the code\n# COMMAND ----------\n# this part is dbt logic for get ref work, do not modify\n\ndef ref(*args, **kwargs):\n    refs = {\"v_qualify_new_documents\": \"incident_management.bronze_zone.v_qualify_new_documents\"}\n    key = '.'.join(args)\n    version = kwargs.get(\"v\") or kwargs.get(\"version\")\n    if version:\n        key += f\".v{version}\"\n    dbt_load_df_function = kwargs.get(\"dbt_load_df_function\")\n    return dbt_load_df_function(refs[key])\n\n\ndef source(*args, dbt_load_df_function):\n    sources = {}\n    key = '.'.join(args)\n    return dbt_load_df_function(sources[key])\n\n\nconfig_dict = {'docs_stage_path': None, 'meta': {'global_inm_policy_schema': {'schema': {'type': 'object', 'properties': {'purpose': {'description': 'Purpose of this policy', 'type': 'string'}, 'objectives': {'description': 'Objectives achieved by this policy', 'type': 'string'}, 'policy_statement': {'description': 'Primary policy statement', 'type': 'string'}, 'in_scope_services': {'description': 'Services explicitly in scope', 'type': 'array'}, 'out_of_scope_services': {'description': 'Services explicitly out of scope', 'type': 'array'}, 'geographical_coverage': {'description': 'Countries/regions covered', 'type': 'array'}, 'business_units_in_scope': {'description': 'Business units covered by the policy', 'type': 'array'}, 'applicability_conditions': {'description': 'Conditions determining when policy applies', 'type': 'array'}, 'exclusions': {'description': 'Explicit exceptions to scope', 'type': 'array'}, 'definitions_and_glossary': {'description': 'Terms, acronyms, and reference standards', 'type': 'object', 'properties': {'defined_terms': {'description': 'Key defined terms', 'type': 'array'}, 'acronyms': {'description': 'Acronyms used within the document', 'type': 'array'}, 'reference_standards': {'description': 'Referenced standards and frameworks', 'type': 'array'}}}}}}}}\n\n\nclass config:\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @staticmethod\n    def get(key, default=None):\n        return config_dict.get(key, default)\n\nclass this:\n    \"\"\"dbt.this() or dbt.this.identifier\"\"\"\n    database = \"incident_management\"\n    schema = \"bronze_zone\"\n    identifier = \"document_question_extracts\"\n    \n    def __repr__(self):\n        return 'incident_management.bronze_zone.document_question_extracts'\n\n\nclass dbtObj:\n    def __init__(self, load_df_function) -> None:\n        self.source = lambda *args: source(*args, dbt_load_df_function=load_df_function)\n        self.ref = lambda *args, **kwargs: ref(*args, **kwargs, dbt_load_df_function=load_df_function)\n        self.config = config\n        self.this = this()\n        self.is_incremental = False\n\n# COMMAND ----------\n\n\n", "relation_name": "incident_management.bronze_zone.document_question_extracts", "batch_results": null}], "elapsed_time": 87.83248949050903, "args": {"defer": false, "vars": {}, "partial_parse": true, "warn_error_options": {"include": [], "exclude": []}, "skip_nodes_if_on_run_start_fails": false, "populate_cache": true, "send_anonymous_usage_stats": false, "log_format": "default", "static_parser": true, "log_format_file": "debug", "version_check": true, "introspect": true, "exclude": [], "project_dir": "/tmp/dbt", "log_file_max_bytes": 10485760, "require_yaml_configuration_for_mf_time_spines": false, "state_modified_compare_more_unrendered_values": false, "strict_mode": false, "cache_selected_only": false, "state_modified_compare_vars": false, "use_colors": true, "invocation_command": "dbt ", "require_explicit_package_overrides_for_builtin_materializations": true, "write_json": true, "use_colors_file": true, "target_path": "/tmp/dbt/target/", "which": "run", "log_level": "info", "macro_debugging": false, "empty": false, "require_nested_cumulative_type_params": false, "require_batched_execution_for_custom_microbatch_strategy": false, "log_level_file": "debug", "quiet": false, "log_path": "/tmp/dbt/logs", "profiles_dir": "/tmp/dbt/", "favor_state": false, "partial_parse_file_diff": true, "require_resource_names_without_spaces": false, "select": ["+bronze_zone.document_question_extracts"], "target": "dev", "print": true, "printer_width": 80, "indirect_selection": "eager", "source_freshness_run_project_hooks": false, "show_resource_report": false}}